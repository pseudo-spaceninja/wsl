#!/bin/bash

# This script changes WSLs automatically generated nameserver
# to the actual DNS servers associated with the interface belonging to
# WSL in Windows.



echo "This script will attempt to check WSLs current DNS servers against those of Windows."
echo "If dissimilar, the script will attempt to rectify by adjusting WSL DNS servers to match."
# Check if superuser
if [[ "$EUID" -ne 0 ]]; then
	echo ""
	echo "This script must be run with super user priveleges"
	echo "Exiting.."
	exit
fi
# Naively check if running WSL with systemd
init_sys_path=$(ps -q 1 -o command= | grep -oP '^\/\S+')
init_sys_name=$(echo ${init_sys_path} | grep -oP '^\/\S+\/\K\S+')
if [[ ! "$(stat $init_sys_path | grep 'link')" = "link" && "$init_sys_name" = "systemd"  ]]; then
	echo "This system is using $init_sys_name."
	echo "checking if Windows executables can be run.. "
	# Checking binfmt_misc to see if WSLInterop is enabled (allows windows executables)
	if [[ ! "$(cat /proc/sys/fs/binfmt_misc/WSLInterop | grep -o 'enabled')" = "enabled" ]]; then
		echo "WSL interop. not enabled, system may not be able to run Windows executables.."
		echo "Attempt to enable WSL interoperability by creating WSLInterop.conf"
		echo "in the folder /usr/lib/binfmt.d and restarting the binfmt service"
		read -st 30 -p "Attempt to enable WSL interoperability (y/n)?" interop
		if [[ "$interop" == [yY] || "$interop" == [yY][eE][sS] || "$interop" == [yY][eE] ]]; then
			# Create and populate WSLInterop.conf file
			touch /usr/lib/binfmt.d/WSLInterop.conf
			echo ":WSLInterop:M::MZ::/init:PF" > /usr/lib/binfmt.d/WSLInterop.conf
			sleep 1
			# Restart related service
			systemctl restart systemd-binfmt.service 
			if [[ ! "$(cat /proc/sys/fs/binfmt_misc/WSLInterop | grep -o 'enabled')" = "enabled" ]]; then
				echo "Failed to enable WSL Interop. Try manually creating WSLInterop.conf"
				echo "in the folder /usr/lib/binfmt.d"
				echo "The file should only contain the following"
				echo ":WSLInterop:M::MZ::/init:PF"
				exit 3 # WSL Interop failure
			fi
		else
			echo "Exiting.."
			exit
		fi
	fi
fi

# The location of the resolv.conf file where the addresses for the nameservers are located.
resolv_conf=/etc/resolv.conf
if [[ -f $resolv_conf ]]; then
        mv $resolv_conf $resolv_conf.bak
fi

# The location of the powershell executable according to WSL.
ps=/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe
echo ""
read -st 30 -p "About to check wsl interface and write to resolv.conf. Continue..(y/n)? " cont
echo ""
if [[ "$cont" == [yY] || "$cont" == [yY][eE] || "$cont" == [yY][eE][sS] ]]; then
	if [[ -e $ps ]]; then
        	echo -e "Running powershell command to get current dns servers and writing those to resolv.conf.\n This usually takes a few seconds...\n"
	else
 		echo "Unable to find host system powershell executable. Exiting.."
   		exit 4 # No powershell executable found 
 	fi
else
        echo "Exiting.."
  exit 10; # Stopped by user
fi
# Write next step in process to stdout.
echo "Running powershell command to get current dns servers. This usually takes a few seconds."

# Host PCs powershell, extract DNS addresses from interface connected to WSL
${ps} -Command '$ErrorActionPreference="Continue"` 
Get-DnsClientServerAddress | Where-Object InterfaceAlias -match ".*(WSL).*" |` 
Select-Object -ExpandProperty ServerAddresses' | \
	awk 'BEGIN { print "# generated by wsl_fix_dns.sh at " strftime("%c"); print } 
	{
		for (s = 1; s <=NF; s++)
			print "nameserver", $s 
	}' | tr -d '\r' > $resolv_conf

echo "Checking interface from ip route..."
# Extract default interface from ip route
default_interface=$(ip route | grep -oP 'dev\s+\K[^ ]+' | sed -n '1p')
echo "Interface in default route is" "${default_interface}"".."
echo "Checking connection..."
# Check interface carrier signal
if [[ $(cat /sys/class/net/$default_interface/carrier) == 1 ]]; then
	echo "Connected!"
	echo "Checking dns server.."
	# Query cloudflare with dig and extract current nameserver address
	dig_dns=$(dig 1.1.1.1 | awk '/SERVER: / {print}' | grep -oP 'SERVER:\s+?\K(\d{1,3}\.){3}\d{1,3}')
	# Read the resolv.conf file line by line.
	echo -e "Current DNS(s) as given by resolv.conf:\n"
	match_found="0"
	while read -r line
	do	
		# Extract addresses from lines in resolv.conf 
		temp_line_dns=$(echo ${line} | grep -oP 'nameserver\s+\K.*(\w|:)$')
		if [[ -n "$temp_line_dns" ]]; then # && $(echo $temp_line_dns | grep -P '\') ]]; then
			echo "	$temp_line_dns"
		fi
		# Check if no prior match and compare ip from resolv.conf to ip from dig.
		if [[ "$match_found" -ne "1" && $temp_line_dns == $dig_dns ]]; then
			matched_dns=$temp_line_dns
			match_found="1"
		fi
	done <"$resolv_conf"
	echo ""
	# Check if match is found
	if [[ "$match_found" == "1" ]]; then
		echo "Success! dns server matches $resolv_conf"
		echo "DNS server as seen externally:" "${dig_dns}"
		echo "DNS server in" "$resolv_conf" ":" "${matched_dns}"
		exit 0 # Success.
	fi
else	
	# If no connection found
        rm $resolv_conf
        mv $resolv_conf.bak $resolv_conf
	echo "Not connected."
	echo "Exiting..."
	exit 1 # Failed to find active connection.
fi

# Connected but DNS addresses does not match
echo "DNS entry in resolv.conf does not match DNS server given by dig"
rm $resolv_conf
mv $resolv_conf.bak $resolv_conf
exit 2 # DNS mismatch.

